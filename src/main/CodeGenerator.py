from functools import wraps

ELF_HEADER = [0x7F, 0x45, 0x4C, 0x46, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x3, 0x0, 0x1, 0x0, 0x0, 0x0, 0x80, 0x84, 0x4, 0x8, 0x34, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x34, 0x0, 0x20, 0x0, 0x1, 0x0, 0x28, 0x0, 0x3, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x4, 0x8, 0x0, 0x80, 0x4, 0x8, 0x97, 0x5, 0x0, 0x0, 0x97, 0x5, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2E, 0x73, 0x68, 0x73, 0x74, 0x72, 0x74, 0x61, 0x62, 0x0, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x54, 0x0, 0x0, 0x0, 0x11, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xB, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0xE0, 0x80, 0x4, 0x8, 0xE0, 0x0, 0x0, 0x0, 0xB7, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x51, 0x53, 0x50, 0xB8, 0x4, 0x0, 0x0, 0x0, 0xBB, 0x1, 0x0, 0x0, 0x0, 0x89, 0xE1, 0xBA, 0x1, 0x0, 0x0, 0x0, 0xCD, 0x80, 0x58, 0x5B, 0x59, 0x5A, 0xC3, 0x55, 0x89, 0xE5, 0x81, 0xEC, 0x24, 0x0, 0x0, 0x0, 0x52, 0x51, 0x53, 0xB8, 0x36, 0x0, 0x0, 0x0, 0xBB, 0x0, 0x0, 0x0, 0x0, 0xB9, 0x1, 0x54, 0x0, 0x0, 0x8D, 0x55, 0xDC, 0xCD, 0x80, 0x81, 0x65, 0xE8, 0xF5, 0xFF, 0xFF, 0xFF, 0xB8, 0x36, 0x0, 0x0, 0x0, 0xBB, 0x0, 0x0, 0x0, 0x0, 0xB9, 0x2, 0x54, 0x0, 0x0, 0x8D, 0x55, 0xDC, 0xCD, 0x80, 0x31, 0xC0, 0x50, 0xB8, 0x3, 0x0, 0x0, 0x0, 0xBB, 0x0, 0x0, 0x0, 0x0, 0x89, 0xE1, 0xBA, 0x1, 0x0, 0x0, 0x0, 0xCD, 0x80, 0x81, 0x4D, 0xE8, 0xA, 0x0, 0x0, 0x0, 0xB8, 0x36, 0x0, 0x0, 0x0, 0xBB, 0x0, 0x0, 0x0, 0x0, 0xB9, 0x2, 0x54, 0x0, 0x0, 0x8D, 0x55, 0xDC, 0xCD, 0x80, 0x58, 0x5B, 0x59, 0x5A, 0x89, 0xEC, 0x5D, 0xC3, 0xB8, 0x4, 0x0, 0x0, 0x0, 0xBB, 0x1, 0x0, 0x0, 0x0, 0xCD, 0x80, 0xC3, 0x90, 0x90, 0x90, 0xB0, 0xA, 0xE8, 0x59, 0xFF, 0xFF, 0xFF, 0xC3, 0x4, 0x30, 0xE8, 0x51, 0xFF, 0xFF, 0xFF, 0xC3, 0x3D, 0x0, 0x0, 0x0, 0x80, 0x75, 0x4E, 0xB0, 0x2D, 0xE8, 0x42, 0xFF, 0xFF, 0xFF, 0xB0, 0x2, 0xE8, 0xE3, 0xFF, 0xFF, 0xFF, 0xB0, 0x1, 0xE8, 0xDC, 0xFF, 0xFF, 0xFF, 0xB0, 0x4, 0xE8, 0xD5, 0xFF, 0xFF, 0xFF, 0xB0, 0x7, 0xE8, 0xCE, 0xFF, 0xFF, 0xFF, 0xB0, 0x4, 0xE8, 0xC7, 0xFF, 0xFF, 0xFF, 0xB0, 0x8, 0xE8, 0xC0, 0xFF, 0xFF, 0xFF, 0xB0, 0x3, 0xE8, 0xB9, 0xFF, 0xFF, 0xFF, 0xB0, 0x6, 0xE8, 0xB2, 0xFF, 0xFF, 0xFF, 0xB0, 0x4, 0xE8, 0xAB, 0xFF, 0xFF, 0xFF, 0xB0, 0x8, 0xE8, 0xA4, 0xFF, 0xFF, 0xFF, 0xC3, 0x3D, 0x0, 0x0, 0x0, 0x0, 0x7D, 0xB, 0x50, 0xB0, 0x2D, 0xE8, 0xEC, 0xFE, 0xFF, 0xFF, 0x58, 0xF7, 0xD8, 0x3D, 0xA, 0x0, 0x0, 0x0, 0xF, 0x8C, 0xEF, 0x0, 0x0, 0x0, 0x3D, 0x64, 0x0, 0x0, 0x0, 0xF, 0x8C, 0xD1, 0x0, 0x0, 0x0, 0x3D, 0xE8, 0x3, 0x0, 0x0, 0xF, 0x8C, 0xB3, 0x0, 0x0, 0x0, 0x3D, 0x10, 0x27, 0x0, 0x0, 0xF, 0x8C, 0x95, 0x0, 0x0, 0x0, 0x3D, 0xA0, 0x86, 0x1, 0x0, 0x7C, 0x7B, 0x3D, 0x40, 0x42, 0xF, 0x0, 0x7C, 0x61, 0x3D, 0x80, 0x96, 0x98, 0x0, 0x7C, 0x47, 0x3D, 0x0, 0xE1, 0xF5, 0x5, 0x7C, 0x2D, 0x3D, 0x0, 0xCA, 0x9A, 0x3B, 0x7C, 0x13, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0x0, 0xCA, 0x9A, 0x3B, 0xF7, 0xFB, 0x52, 0xE8, 0x30, 0xFF, 0xFF, 0xFF, 0x58, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0x0, 0xE1, 0xF5, 0x5, 0xF7, 0xFB, 0x52, 0xE8, 0x1D, 0xFF, 0xFF, 0xFF, 0x58, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0x80, 0x96, 0x98, 0x0, 0xF7, 0xFB, 0x52, 0xE8, 0xA, 0xFF, 0xFF, 0xFF, 0x58, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0x40, 0x42, 0xF, 0x0, 0xF7, 0xFB, 0x52, 0xE8, 0xF7, 0xFE, 0xFF, 0xFF, 0x58, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0xA0, 0x86, 0x1, 0x0, 0xF7, 0xFB, 0x52, 0xE8, 0xE4, 0xFE, 0xFF, 0xFF, 0x58, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0x10, 0x27, 0x0, 0x0, 0xF7, 0xFB, 0x52, 0xE8, 0xD1, 0xFE, 0xFF, 0xFF, 0x58, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0xE8, 0x3, 0x0, 0x0, 0xF7, 0xFB, 0x52, 0xE8, 0xBE, 0xFE, 0xFF, 0xFF, 0x58, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0x64, 0x0, 0x0, 0x0, 0xF7, 0xFB, 0x52, 0xE8, 0xAB, 0xFE, 0xFF, 0xFF, 0x58, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0xA, 0x0, 0x0, 0x0, 0xF7, 0xFB, 0x52, 0xE8, 0x98, 0xFE, 0xFF, 0xFF, 0x58, 0xE8, 0x92, 0xFE, 0xFF, 0xFF, 0xC3, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0xB8, 0x1, 0x0, 0x0, 0x0, 0xBB, 0x0, 0x0, 0x0, 0x0, 0xCD, 0x80, 0x90, 0x90, 0x90, 0x90, 0xB9, 0x0, 0x0, 0x0, 0x0, 0xB3, 0x3, 0x51, 0x53, 0xE8, 0xDE, 0xFD, 0xFF, 0xFF, 0x5B, 0x59, 0x3C, 0xA, 0xF, 0x84, 0x34, 0x1, 0x0, 0x0, 0x3C, 0x7F, 0xF, 0x84, 0x94, 0x0, 0x0, 0x0, 0x3C, 0x2D, 0xF, 0x84, 0x9, 0x1, 0x0, 0x0, 0x3C, 0x30, 0x7C, 0xDB, 0x3C, 0x39, 0x7F, 0xD7, 0x2C, 0x30, 0x80, 0xFB, 0x0, 0x74, 0xD0, 0x80, 0xFB, 0x2, 0x75, 0xC, 0x81, 0xF9, 0x0, 0x0, 0x0, 0x0, 0x75, 0x4, 0x3C, 0x0, 0x74, 0xBF, 0x80, 0xFB, 0x3, 0x75, 0xA, 0x3C, 0x0, 0x75, 0x4, 0xB3, 0x0, 0xEB, 0x2, 0xB3, 0x1, 0x81, 0xF9, 0xCC, 0xCC, 0xCC, 0xC, 0x7F, 0xA8, 0x81, 0xF9, 0x34, 0x33, 0x33, 0xF3, 0x7C, 0xA0, 0x88, 0xC7, 0xB8, 0xA, 0x0, 0x0, 0x0, 0xF7, 0xE9, 0x3D, 0x8, 0x0, 0x0, 0x80, 0x74, 0x11, 0x3D, 0xF8, 0xFF, 0xFF, 0x7F, 0x75, 0x13, 0x80, 0xFF, 0x7, 0x7E, 0xE, 0xE9, 0x7F, 0xFF, 0xFF, 0xFF, 0x80, 0xFF, 0x8, 0xF, 0x8F, 0x76, 0xFF, 0xFF, 0xFF, 0xB9, 0x0, 0x0, 0x0, 0x0, 0x88, 0xF9, 0x80, 0xFB, 0x2, 0x74, 0x4, 0x1, 0xC1, 0xEB, 0x3, 0x29, 0xC8, 0x91, 0x88, 0xF8, 0x51, 0x53, 0xE8, 0xCB, 0xFD, 0xFF, 0xFF, 0x5B, 0x59, 0xE9, 0x53, 0xFF, 0xFF, 0xFF, 0x80, 0xFB, 0x3, 0xF, 0x84, 0x4A, 0xFF, 0xFF, 0xFF, 0x51, 0x53, 0xB0, 0x8, 0xE8, 0xA, 0xFD, 0xFF, 0xFF, 0xB0, 0x20, 0xE8, 0x3, 0xFD, 0xFF, 0xFF, 0xB0, 0x8, 0xE8, 0xFC, 0xFC, 0xFF, 0xFF, 0x5B, 0x59, 0x80, 0xFB, 0x0, 0x75, 0x7, 0xB3, 0x3, 0xE9, 0x25, 0xFF, 0xFF, 0xFF, 0x80, 0xFB, 0x2, 0x75, 0xF, 0x81, 0xF9, 0x0, 0x0, 0x0, 0x0, 0x75, 0x7, 0xB3, 0x3, 0xE9, 0x11, 0xFF, 0xFF, 0xFF, 0x89, 0xC8, 0xB9, 0xA, 0x0, 0x0, 0x0, 0xBA, 0x0, 0x0, 0x0, 0x0, 0x3D, 0x0, 0x0, 0x0, 0x0, 0x7D, 0x8, 0xF7, 0xD8, 0xF7, 0xF9, 0xF7, 0xD8, 0xEB, 0x2, 0xF7, 0xF9, 0x89, 0xC1, 0x81, 0xF9, 0x0, 0x0, 0x0, 0x0, 0xF, 0x85, 0xE6, 0xFE, 0xFF, 0xFF, 0x80, 0xFB, 0x2, 0xF, 0x84, 0xDD, 0xFE, 0xFF, 0xFF, 0xB3, 0x3, 0xE9, 0xD6, 0xFE, 0xFF, 0xFF, 0x80, 0xFB, 0x3, 0xF, 0x85, 0xCD, 0xFE, 0xFF, 0xFF, 0xB0, 0x2D, 0x51, 0x53, 0xE8, 0x8D, 0xFC, 0xFF, 0xFF, 0x5B, 0x59, 0xB3, 0x2, 0xE9, 0xBB, 0xFE, 0xFF, 0xFF, 0x80, 0xFB, 0x3, 0xF, 0x84, 0xB2, 0xFE, 0xFF, 0xFF, 0x80, 0xFB, 0x2, 0x75, 0xC, 0x81, 0xF9, 0x0, 0x0, 0x0, 0x0, 0xF, 0x84, 0xA1, 0xFE, 0xFF, 0xFF, 0x51, 0xE8, 0x4, 0xFD, 0xFF, 0xFF, 0x59, 0x89, 0xC8, 0xC3]

JMP_DIR = [0xE9]
WORD_SIZE = 4
WORD_PADDING = [0x0 for i in range(WORD_SIZE)]
MAX_INT = 2 ** 32

MOV_EDI = [0xBF]
MOV_ECX = [0xB9]
MOV_EDX = [0xBA]
MOV_EAX_VAR = [0x8B, 0x87]
MOV_EAX_NUM = [0xB8]

CALL = [0xE8]
ASSIGN_VAR = [0x89, 0x87]

READLN_ADDRESS = 784
WRITE_STRING = 368
WRITE_LN = 384
WRITE_EXP = 400
PROGRAM_EXIT = 768

VIRTUAL_ADDRESS = int("".join([format(b, '08b') for b in ELF_HEADER[63:59:-1]]), 2)
ADDRESS = int("".join([format(b, '08b') for b in ELF_HEADER[196:192:-1]]), 2)

POP_EAX = [0x58]
PUSH_EAX = [0x50]
POP_EBX = [0x5B]
RET = [0xC3]

IMUL = [0xF7, 0xEB]
IDIV = [0xF7, 0xFB]
CDQ = [0x99]
XCHG = [0x93]
NEG = [0xF7, 0xD8]
ADD = [0x01, 0xD8]
SUB = [0x29, 0xD8]

CMP = [0x39, 0xC3]

FILE_SIZE_POS = 68
MEMORY_SIZE_POS = 72
SIZE_POS = 201
VAR_TEXT = 224

OP_EQ = [0x74]
OP_NE = [0x75]
OP_GT = [0x7F]
OP_GE = [0x7D]
OP_LT = [0x7C]
OP_LE = [0x7E]
OP_ODD = [0x7B]

TEST_AL = [0xA8]

COMP_OP_MAP = {"EQL": OP_EQ, "NEQ": OP_NE, "GTR": OP_GT, "GEQ": OP_GE, "LSS": OP_LT, "LEQ": OP_LE}


class _CodeGenerator(object):

    def __init__(self):
        self._buffer = ELF_HEADER + MOV_EDI + WORD_PADDING
        self._block_stack = []
        self._if_stack = []
        self._while_stack = []

    @property
    def buffer(self):
        return self._buffer

    def block_jmp(self):
        self._buffer += JMP_DIR + WORD_PADDING
        self._block_stack.append(self.len())

    def fix_block_jmp(self):
        address = self._block_stack.pop()
        if address == self.len():
            self._buffer = self._buffer[:address - 5]
        else:
            self._buffer = self._buffer[:address - 4] + self.l_endian(self.len() - address) + self._buffer[address:]

    def calc_jmp(self, to_address, from_address=None):
        if not from_address:
            from_address = self.len()
            if from_address > to_address:
                from_address = from_address + 5
        offset = _CodeGenerator.two_complement(to_address - from_address)
        return _CodeGenerator.l_endian(offset)

    @staticmethod
    def two_complement(value):
        return MAX_INT + value

    @staticmethod
    def l_endian(address):
        binary = format(address, '032b')
        return [int(binary[24:32], 2), int(binary[16:24], 2), int(binary[8:16], 2), int(binary[0:8], 2)]

    def len(self):
        return len(self._buffer)

    def readln(self, var):
        self.buffer.extend(CALL + self.calc_jmp(READLN_ADDRESS))
        self.buffer.extend(ASSIGN_VAR + self.l_endian(var * WORD_SIZE))

    def write_string(self, string):
        string = string.replace('\'', '').replace('\"', '')
        self.buffer.extend(MOV_ECX + self.l_endian(VIRTUAL_ADDRESS + self.len() + 20))
        self.buffer.extend(MOV_EDX + self.l_endian(len(string)))
        self.buffer.extend(CALL + self.calc_jmp(WRITE_STRING))
        self.buffer.extend(JMP_DIR + self.l_endian(len(string)))
        self.buffer.extend([ord(char) for char in string])

    def writeln(self):
        self.buffer.extend(CALL + self.calc_jmp(WRITE_LN))

    def write_exp(self):
        self._pop_eax()
        self.buffer.extend(CALL + self.calc_jmp(WRITE_EXP))

    def _pop_eax(self):
        if self.buffer[-1] == PUSH_EAX[0]:
            self._buffer = self.buffer[:-1]
        else:
            self.buffer.extend(POP_EAX)

    def _push_eax(self):
        self.buffer.extend(PUSH_EAX)

    def _pop_ebx(self):
        self.buffer.extend(POP_EBX)

    def call(self, address):
        self.buffer.extend(CALL + self.calc_jmp(address))

    def assign(self, var):
        self._pop_eax()
        self.buffer.extend(ASSIGN_VAR + self.l_endian(var * WORD_SIZE))

    def factor_var(self, var):
        self.buffer.extend(MOV_EAX_VAR + self.l_endian(var * WORD_SIZE))
        self._push_eax()

    def factor_number(self, number):
        self.buffer.extend(MOV_EAX_NUM + self.l_endian(number))
        self._push_eax()

    def ret(self):
        self.buffer.extend(RET)

    def mult(self):
        self._pop_eax()
        self._pop_ebx()
        self.buffer.extend(IMUL)
        self._push_eax()

    def div(self):
        self._pop_eax()
        self._pop_ebx()
        self.buffer.extend(XCHG + CDQ + IDIV)
        self._push_eax()

    def neg(self):
        self._pop_eax()
        self.buffer.extend(NEG)
        self._push_eax()

    def add(self):
        self._pop_eax()
        self._pop_ebx()
        self.buffer.extend(ADD)
        self._push_eax()

    def sub(self):
        self._pop_eax()
        self._pop_ebx()
        self.buffer.extend(XCHG + SUB)
        self._push_eax()

    def finish(self, var_count):
        self.buffer.extend(JMP_DIR + self.calc_jmp(PROGRAM_EXIT))
        self._buffer_fix(len(ELF_HEADER) + 1, self.l_endian(VIRTUAL_ADDRESS + self.len()))
        for i in range(var_count):
            self.buffer.extend(WORD_PADDING)
        self._buffer_fix(FILE_SIZE_POS)
        self._buffer_fix(MEMORY_SIZE_POS)
        self._buffer_fix(SIZE_POS, self.l_endian(self.len() - VAR_TEXT))

        return self.buffer

    def _buffer_fix(self, pos, fix=None):
        if not fix:
            fix = self.l_endian(self.len())
        self._buffer = self.buffer[0: pos] + fix + self.buffer[pos + len(fix):]

    def condition(self, operator):
        operator_op_code = COMP_OP_MAP[operator]
        if not operator_op_code:
            raise ValueError("Invalid operator")
        self._pop_eax()
        self._pop_ebx()
        self.buffer.extend(CMP)
        self.buffer.extend(operator_op_code + [5])
        self._if_stack.append(self.len())
        self.buffer.extend(JMP_DIR + WORD_PADDING)

    def comp_odd(self):
        self._pop_eax()
        self.buffer.extend(TEST_AL + [0x01])
        self.buffer.extend(OP_ODD + [5])
        self._if_stack.append(self.len())
        self.buffer.extend(JMP_DIR + WORD_PADDING)

    def fix_if_jmp(self):
        address = self._if_stack.pop()
        self._buffer_fix(address + 1, self.l_endian(self.len() - address - 5))

    def init_while(self):
        self._while_stack.append(self.len())

    def while_loop(self):
        address = self._while_stack.pop()
        self.buffer.extend(JMP_DIR + self.calc_jmp(address))


class CodeGenerator:
    def __init__(self):
        self.code_gen = _CodeGenerator()
        self.disabled = False

    def __getattr__(self, attr):
        func = getattr(self.code_gen, attr)
        if not callable(func):
            if self.disabled:
                return None
            else:
                return func

        @wraps(func)
        def _wrapped(*args, **kwargs):
            if self.disabled:
                return None
            else:
                return func(*args, **kwargs)

        return _wrapped

    def disable(self):
        self.disabled = True
