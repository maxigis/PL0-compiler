import os
import stat

ELF_HEADER = [0x7F, 0x45, 0x4C, 0x46, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x3, 0x0, 0x1, 0x0, 0x0, 0x0, 0x80, 0x84, 0x4, 0x8, 0x34, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x34, 0x0, 0x20, 0x0, 0x1, 0x0, 0x28, 0x0, 0x3, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x4, 0x8, 0x0, 0x80, 0x4, 0x8, 0x97, 0x5, 0x0, 0x0, 0x97, 0x5, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2E, 0x73, 0x68, 0x73, 0x74, 0x72, 0x74, 0x61, 0x62, 0x0, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x54, 0x0, 0x0, 0x0, 0x11, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xB, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0xE0, 0x80, 0x4, 0x8, 0xE0, 0x0, 0x0, 0x0, 0xB7, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x51, 0x53, 0x50, 0xB8, 0x4, 0x0, 0x0, 0x0, 0xBB, 0x1, 0x0, 0x0, 0x0, 0x89, 0xE1, 0xBA, 0x1, 0x0, 0x0, 0x0, 0xCD, 0x80, 0x58, 0x5B, 0x59, 0x5A, 0xC3, 0x55, 0x89, 0xE5, 0x81, 0xEC, 0x24, 0x0, 0x0, 0x0, 0x52, 0x51, 0x53, 0xB8, 0x36, 0x0, 0x0, 0x0, 0xBB, 0x0, 0x0, 0x0, 0x0, 0xB9, 0x1, 0x54, 0x0, 0x0, 0x8D, 0x55, 0xDC, 0xCD, 0x80, 0x81, 0x65, 0xE8, 0xF5, 0xFF, 0xFF, 0xFF, 0xB8, 0x36, 0x0, 0x0, 0x0, 0xBB, 0x0, 0x0, 0x0, 0x0, 0xB9, 0x2, 0x54, 0x0, 0x0, 0x8D, 0x55, 0xDC, 0xCD, 0x80, 0x31, 0xC0, 0x50, 0xB8, 0x3, 0x0, 0x0, 0x0, 0xBB, 0x0, 0x0, 0x0, 0x0, 0x89, 0xE1, 0xBA, 0x1, 0x0, 0x0, 0x0, 0xCD, 0x80, 0x81, 0x4D, 0xE8, 0xA, 0x0, 0x0, 0x0, 0xB8, 0x36, 0x0, 0x0, 0x0, 0xBB, 0x0, 0x0, 0x0, 0x0, 0xB9, 0x2, 0x54, 0x0, 0x0, 0x8D, 0x55, 0xDC, 0xCD, 0x80, 0x58, 0x5B, 0x59, 0x5A, 0x89, 0xEC, 0x5D, 0xC3, 0xB8, 0x4, 0x0, 0x0, 0x0, 0xBB, 0x1, 0x0, 0x0, 0x0, 0xCD, 0x80, 0xC3, 0x90, 0x90, 0x90, 0xB0, 0xA, 0xE8, 0x59, 0xFF, 0xFF, 0xFF, 0xC3, 0x4, 0x30, 0xE8, 0x51, 0xFF, 0xFF, 0xFF, 0xC3, 0x3D, 0x0, 0x0, 0x0, 0x80, 0x75, 0x4E, 0xB0, 0x2D, 0xE8, 0x42, 0xFF, 0xFF, 0xFF, 0xB0, 0x2, 0xE8, 0xE3, 0xFF, 0xFF, 0xFF, 0xB0, 0x1, 0xE8, 0xDC, 0xFF, 0xFF, 0xFF, 0xB0, 0x4, 0xE8, 0xD5, 0xFF, 0xFF, 0xFF, 0xB0, 0x7, 0xE8, 0xCE, 0xFF, 0xFF, 0xFF, 0xB0, 0x4, 0xE8, 0xC7, 0xFF, 0xFF, 0xFF, 0xB0, 0x8, 0xE8, 0xC0, 0xFF, 0xFF, 0xFF, 0xB0, 0x3, 0xE8, 0xB9, 0xFF, 0xFF, 0xFF, 0xB0, 0x6, 0xE8, 0xB2, 0xFF, 0xFF, 0xFF, 0xB0, 0x4, 0xE8, 0xAB, 0xFF, 0xFF, 0xFF, 0xB0, 0x8, 0xE8, 0xA4, 0xFF, 0xFF, 0xFF, 0xC3, 0x3D, 0x0, 0x0, 0x0, 0x0, 0x7D, 0xB, 0x50, 0xB0, 0x2D, 0xE8, 0xEC, 0xFE, 0xFF, 0xFF, 0x58, 0xF7, 0xD8, 0x3D, 0xA, 0x0, 0x0, 0x0, 0xF, 0x8C, 0xEF, 0x0, 0x0, 0x0, 0x3D, 0x64, 0x0, 0x0, 0x0, 0xF, 0x8C, 0xD1, 0x0, 0x0, 0x0, 0x3D, 0xE8, 0x3, 0x0, 0x0, 0xF, 0x8C, 0xB3, 0x0, 0x0, 0x0, 0x3D, 0x10, 0x27, 0x0, 0x0, 0xF, 0x8C, 0x95, 0x0, 0x0, 0x0, 0x3D, 0xA0, 0x86, 0x1, 0x0, 0x7C, 0x7B, 0x3D, 0x40, 0x42, 0xF, 0x0, 0x7C, 0x61, 0x3D, 0x80, 0x96, 0x98, 0x0, 0x7C, 0x47, 0x3D, 0x0, 0xE1, 0xF5, 0x5, 0x7C, 0x2D, 0x3D, 0x0, 0xCA, 0x9A, 0x3B, 0x7C, 0x13, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0x0, 0xCA, 0x9A, 0x3B, 0xF7, 0xFB, 0x52, 0xE8, 0x30, 0xFF, 0xFF, 0xFF, 0x58, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0x0, 0xE1, 0xF5, 0x5, 0xF7, 0xFB, 0x52, 0xE8, 0x1D, 0xFF, 0xFF, 0xFF, 0x58, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0x80, 0x96, 0x98, 0x0, 0xF7, 0xFB, 0x52, 0xE8, 0xA, 0xFF, 0xFF, 0xFF, 0x58, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0x40, 0x42, 0xF, 0x0, 0xF7, 0xFB, 0x52, 0xE8, 0xF7, 0xFE, 0xFF, 0xFF, 0x58, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0xA0, 0x86, 0x1, 0x0, 0xF7, 0xFB, 0x52, 0xE8, 0xE4, 0xFE, 0xFF, 0xFF, 0x58, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0x10, 0x27, 0x0, 0x0, 0xF7, 0xFB, 0x52, 0xE8, 0xD1, 0xFE, 0xFF, 0xFF, 0x58, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0xE8, 0x3, 0x0, 0x0, 0xF7, 0xFB, 0x52, 0xE8, 0xBE, 0xFE, 0xFF, 0xFF, 0x58, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0x64, 0x0, 0x0, 0x0, 0xF7, 0xFB, 0x52, 0xE8, 0xAB, 0xFE, 0xFF, 0xFF, 0x58, 0xBA, 0x0, 0x0, 0x0, 0x0, 0xBB, 0xA, 0x0, 0x0, 0x0, 0xF7, 0xFB, 0x52, 0xE8, 0x98, 0xFE, 0xFF, 0xFF, 0x58, 0xE8, 0x92, 0xFE, 0xFF, 0xFF, 0xC3, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0xB8, 0x1, 0x0, 0x0, 0x0, 0xBB, 0x0, 0x0, 0x0, 0x0, 0xCD, 0x80, 0x90, 0x90, 0x90, 0x90, 0xB9, 0x0, 0x0, 0x0, 0x0, 0xB3, 0x3, 0x51, 0x53, 0xE8, 0xDE, 0xFD, 0xFF, 0xFF, 0x5B, 0x59, 0x3C, 0xA, 0xF, 0x84, 0x34, 0x1, 0x0, 0x0, 0x3C, 0x7F, 0xF, 0x84, 0x94, 0x0, 0x0, 0x0, 0x3C, 0x2D, 0xF, 0x84, 0x9, 0x1, 0x0, 0x0, 0x3C, 0x30, 0x7C, 0xDB, 0x3C, 0x39, 0x7F, 0xD7, 0x2C, 0x30, 0x80, 0xFB, 0x0, 0x74, 0xD0, 0x80, 0xFB, 0x2, 0x75, 0xC, 0x81, 0xF9, 0x0, 0x0, 0x0, 0x0, 0x75, 0x4, 0x3C, 0x0, 0x74, 0xBF, 0x80, 0xFB, 0x3, 0x75, 0xA, 0x3C, 0x0, 0x75, 0x4, 0xB3, 0x0, 0xEB, 0x2, 0xB3, 0x1, 0x81, 0xF9, 0xCC, 0xCC, 0xCC, 0xC, 0x7F, 0xA8, 0x81, 0xF9, 0x34, 0x33, 0x33, 0xF3, 0x7C, 0xA0, 0x88, 0xC7, 0xB8, 0xA, 0x0, 0x0, 0x0, 0xF7, 0xE9, 0x3D, 0x8, 0x0, 0x0, 0x80, 0x74, 0x11, 0x3D, 0xF8, 0xFF, 0xFF, 0x7F, 0x75, 0x13, 0x80, 0xFF, 0x7, 0x7E, 0xE, 0xE9, 0x7F, 0xFF, 0xFF, 0xFF, 0x80, 0xFF, 0x8, 0xF, 0x8F, 0x76, 0xFF, 0xFF, 0xFF, 0xB9, 0x0, 0x0, 0x0, 0x0, 0x88, 0xF9, 0x80, 0xFB, 0x2, 0x74, 0x4, 0x1, 0xC1, 0xEB, 0x3, 0x29, 0xC8, 0x91, 0x88, 0xF8, 0x51, 0x53, 0xE8, 0xCB, 0xFD, 0xFF, 0xFF, 0x5B, 0x59, 0xE9, 0x53, 0xFF, 0xFF, 0xFF, 0x80, 0xFB, 0x3, 0xF, 0x84, 0x4A, 0xFF, 0xFF, 0xFF, 0x51, 0x53, 0xB0, 0x8, 0xE8, 0xA, 0xFD, 0xFF, 0xFF, 0xB0, 0x20, 0xE8, 0x3, 0xFD, 0xFF, 0xFF, 0xB0, 0x8, 0xE8, 0xFC, 0xFC, 0xFF, 0xFF, 0x5B, 0x59, 0x80, 0xFB, 0x0, 0x75, 0x7, 0xB3, 0x3, 0xE9, 0x25, 0xFF, 0xFF, 0xFF, 0x80, 0xFB, 0x2, 0x75, 0xF, 0x81, 0xF9, 0x0, 0x0, 0x0, 0x0, 0x75, 0x7, 0xB3, 0x3, 0xE9, 0x11, 0xFF, 0xFF, 0xFF, 0x89, 0xC8, 0xB9, 0xA, 0x0, 0x0, 0x0, 0xBA, 0x0, 0x0, 0x0, 0x0, 0x3D, 0x0, 0x0, 0x0, 0x0, 0x7D, 0x8, 0xF7, 0xD8, 0xF7, 0xF9, 0xF7, 0xD8, 0xEB, 0x2, 0xF7, 0xF9, 0x89, 0xC1, 0x81, 0xF9, 0x0, 0x0, 0x0, 0x0, 0xF, 0x85, 0xE6, 0xFE, 0xFF, 0xFF, 0x80, 0xFB, 0x2, 0xF, 0x84, 0xDD, 0xFE, 0xFF, 0xFF, 0xB3, 0x3, 0xE9, 0xD6, 0xFE, 0xFF, 0xFF, 0x80, 0xFB, 0x3, 0xF, 0x85, 0xCD, 0xFE, 0xFF, 0xFF, 0xB0, 0x2D, 0x51, 0x53, 0xE8, 0x8D, 0xFC, 0xFF, 0xFF, 0x5B, 0x59, 0xB3, 0x2, 0xE9, 0xBB, 0xFE, 0xFF, 0xFF, 0x80, 0xFB, 0x3, 0xF, 0x84, 0xB2, 0xFE, 0xFF, 0xFF, 0x80, 0xFB, 0x2, 0x75, 0xC, 0x81, 0xF9, 0x0, 0x0, 0x0, 0x0, 0xF, 0x84, 0xA1, 0xFE, 0xFF, 0xFF, 0x51, 0xE8, 0x4, 0xFD, 0xFF, 0xFF, 0x59, 0x89, 0xC8, 0xC3]

INITIAL_EDI = [0x0, 0x0, 0x0, 0x0]

MOV_EDI = [0xBF]
MOV_EAX_VAR = [0x8B, 0x87]
MOV_VAR = [0x89, 0x87]
MOV_EAX_NUM = [0xB8]
MOV_ECX_NUM = [0xB9]
MOV_EDX_NUM = [0xBA]

PUSH_EAX = [0x50]
POP_EAX = [0x58]
POP_EBX = [0x5B]

ADD = [0x01, 0xD8]
SUB = [0x93, 0x29, 0xD8]
MUL = [0xF7, 0xEB]
DIV = [0x93, 0x99, 0xF7, 0xFB]
INVERT = [0xF7, 0xD8]

JMP = [0xE9]
CALL = [0xE8]
RETURN = [0xC3]
OPERATORS_DIC = {"LSS": [0x7C, 0x05], "GTR": [0x7F, 0x05], "EQL": [0x74, 0x05], "GEQ": [0x7D, 0x05], "LEQ": [0x7E, 0x05], "NEQ": [0x75, 0x05]}

ODD = [0xA8, 0x01, 0x7B, 0x05]
CMP_EAX_EBX = [0x39, 0xC3]

FILE_SIZE_INDEX = 68
MEMORY_SIZE_INDEX = 72
SIZE_INDEX = 201
TEXT_INDEX = 224
EDI_INDEX = 1151

VIRTUAL_ADDRESS = 134512640
ADDRESS = 134512864
VAR_SIZE = 4
WORD_SIZE = 4294967296

PROGRAM_END = 768
IO_OUT_INT = 400
IO_OUT_STRING = 368
IO_OUT_NEW_LINE = 384
IO_INT_IN = 784


class CodeGenerator(object):

    def __init__(self, output_filename):
        self.filename = output_filename
        self.buffer = []
        self.stack = []
        self.stack_while = []
        self.stack_blocks = []
        self.buffer += ELF_HEADER
        self._init_edi()

    def _init_edi(self):
        self.buffer = self.buffer + MOV_EDI + INITIAL_EDI

    def flush(self, var_count):
        self._finalize_buffer(var_count)

        output_file = open(self.filename, "wb")
        output_file.write(bytearray(self.buffer))
        output_file.close()

        st = os.stat(self.filename)
        os.chmod(self.filename, st.st_mode | stat.S_IEXEC)

    def _finalize_buffer(self, var_count):
        self.buffer = self.buffer + JMP + self._calc_jump(PROGRAM_END, self.buffer_size() + 5)
        self.buffer = self.buffer[:EDI_INDEX + 1] + MOV_EDI + self._l_endian(VIRTUAL_ADDRESS + self.buffer_size()) + self.buffer[EDI_INDEX + 6:]
        self.buffer = self.buffer + self._var_padding(var_count)
        self.buffer = self.buffer[0: FILE_SIZE_INDEX] + self._l_endian(self.buffer_size()) + self.buffer[FILE_SIZE_INDEX + 4:]
        self.buffer = self.buffer[0: MEMORY_SIZE_INDEX] + self._l_endian(self.buffer_size()) + self.buffer[MEMORY_SIZE_INDEX + 4:]
        self.buffer = self.buffer[0: SIZE_INDEX] + self._l_endian(self.buffer_size() - TEXT_INDEX) + self.buffer[SIZE_INDEX + 4:]

    def _push_eax(self):
        self.buffer += PUSH_EAX

    def _pop_eax(self):
        self.buffer += POP_EAX

    def factor_number(self, value):
        int_value = int(value)
        self.buffer += MOV_EAX_NUM + self._l_endian(int_value)
        self._push_eax()

    def factor_var(self, num_var):
        self.buffer += MOV_EAX_VAR + self._l_endian(VAR_SIZE * num_var)
        self._push_eax()

    def times(self):
        self._pop_eax()
        self.buffer += POP_EBX + MUL
        self._push_eax()

    def div(self):
        self._pop_eax()
        self.buffer += POP_EBX + DIV
        self._push_eax()

    def add(self):
        self._pop_eax()
        self.buffer += POP_EBX + ADD
        self._push_eax()

    def minus(self):
        self._pop_eax()
        self.buffer += POP_EBX + SUB
        self._push_eax()

    def add_or_minus(self, op):
        if op == 'PLUS':
            self.add()
        elif op == 'MINUS':
            self.minus()
        else:
            raise ValueError("Invalid operator")

    def becomes(self, numero_var):
        self._pop_eax()
        self.buffer += MOV_VAR + self._l_endian(VAR_SIZE * numero_var)

    def invert(self):
        self._pop_eax()
        self.buffer += INVERT
        self._push_eax()

    def write(self, value=None):
        if value:
            # dirty hack
            val = value.replace('\'', '').replace('\"', '')

            offset = 20
            self.buffer += MOV_ECX_NUM + self._l_endian(ADDRESS - 0xe0 + self.buffer_size() + offset)
            self.buffer += MOV_EDX_NUM + self._l_endian(len(val))
            self.buffer += CALL + self._calc_jump(IO_OUT_STRING, self.buffer_size() + 5)
            self.buffer += JMP + self._l_endian(len(val) + 1)
            self.buffer += [ord(i) for i in val] + [0]
        else:
            self._pop_eax()
            self.buffer += CALL + self._calc_jump(IO_OUT_INT, (self.buffer_size() + 5))

    def writeln(self):
        self.buffer += CALL + self._calc_jump(IO_OUT_NEW_LINE, (self.buffer_size() + 5))

    def readln(self, numero_var):
        self.buffer += CALL + self._calc_jump(IO_INT_IN, self.buffer_size() + 5)
        self.buffer += MOV_VAR + self._l_endian(VAR_SIZE * numero_var)

    def odd(self):
        self._pop_eax()
        self.buffer += ODD
        self.buffer += JMP + INITIAL_EDI
        self.stack.append(self.buffer_size())

    def compare(self, comparator):
        self._pop_eax()
        self.buffer += POP_EBX + CMP_EAX_EBX + OPERATORS_DIC[comparator]
        self.buffer += JMP + INITIAL_EDI
        self.stack.append(self.buffer_size())

    def fix_up(self):
        last = self.stack.pop()
        current = self.buffer_size()
        distance = current - last
        self.buffer = self.buffer[0: last - 5] + JMP + self._l_endian(distance) + self.buffer[last:]

    def init_while(self):
        self.stack_while.append(self.buffer_size())

    def fix_while(self):
        pos_while = self.stack_while.pop()
        self.buffer += JMP + self._calc_jump(pos_while, self.buffer_size() + 5)

    def read_ln(self, var):
        self.buffer += CALL + self._calc_jump(IO_INT_IN, self.buffer_size() + 5)
        self.buffer += MOV_VAR + self._l_endian(VAR_SIZE * var)

    def call(self, position):
        self.buffer += CALL + self._calc_jump(position, self.buffer_size() + 5)

    def init_block(self):
        self.buffer += JMP + [0, 0, 0, 0]
        self.stack_blocks.append(self.buffer_size())

    def fix_block(self):
        block_address = self.stack_blocks.pop()
        distance = self.buffer_size() - int(block_address)

        if distance == 0:
            self.buffer = self.buffer[0: block_address - 5] + self.buffer[block_address + 5:]
        else:
            self.buffer = self.buffer[0: block_address - 4] + self._l_endian(distance) + self.buffer[block_address:]

    def add_return(self):
        self.buffer += RETURN

    def buffer_size(self):
        return len(self.buffer)

    @staticmethod
    def _calc_jump(target, current):
        return CodeGenerator._l_endian(WORD_SIZE + target - current)

    @staticmethod
    def _l_endian(value):
        binary = format(value, '032b')
        return [int(binary[24:32], 2), int(binary[16:24], 2), int(binary[8:16], 2), int(binary[0:8], 2)]

    @staticmethod
    def _var_padding(cant):
        return [0 for i in range(cant * VAR_SIZE)]
